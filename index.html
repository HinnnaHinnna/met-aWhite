<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>메타공백; 두억시니의 낭독</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Language" content="ko" />
  <meta name="description" content="공백으로 공백을 섞어짜기" />
  <meta name="keywords" content="메타공백, 두억시니, 공백문자, 쓰기, 말하기" />
  <meta name="author" content="김지영" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="메타공백; 두억시니의 낭독" />
  <meta property="og:description" content="공백으로 공백을 섞어짜기" />
  <meta property="og:locale" content="ko_KR" />
  <meta name="theme-color" content="#ffffff" />

  <style>
    @font-face {
      font-family: 'MapoGoldenPier';
      src: url('https://gcore.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/MapoGoldenPierA.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      letter-spacing: -5px;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      font-family: 'MapoGoldenPier', 'Noto Sans KR', sans-serif;
      background: #ffffff;
      display: flex;
      justify-content: center;
      position: relative;
      cursor: pointer;
    }

    .text-output {
      font-size: 1.5rem;
      white-space: pre-wrap;
      padding: 1.5rem;
      padding-top: 20%;
      min-height: 1200px;
      max-width: 800px;
      width: 100%;
      text-align: left;
      line-height: 1.9;
      box-sizing: border-box;
      overflow-wrap: break-word;
      word-break: keep-all;
      transition: padding 0.3s ease;
    }

    .char {
      display: inline-block;
      -webkit-text-stroke-color: black;
      color: black;
      -webkit-text-stroke-linejoin: round;
      -webkit-text-stroke-linecap: round;
    }

    .bit-space {
      color: transparent;
      position: relative;
      cursor: help;
    }
    .bit-space::after { content: " "; position: absolute; color: rgba(0,0,0,0); }

    footer {
      position: fixed; bottom: 0; left: 0; width: 100%;
      text-align: left; font-size: 0.8rem; font-weight: 300; padding: 1rem;
      font-family: 'Noto Sans KR'; pointer-events: none;
    }

    /* 번역-세이프 모드가 켜지면, 인터랙션이 멈춘 상태임을 사용자에게(거의 보이지 않게) 표시 */
    #statusHint {
      position: fixed; top: 10px; right: 10px;
      font-family: 'Noto Sans KR'; font-size: 0.8rem; font-weight: 300;
      color: rgba(0,0,0,0.25); pointer-events: none;
    }

    /* 언어 앵커: 한국어 문양을 화면 밖에 배치(언어 탐지 바이어스) */
    #langAnchor {
      position: absolute; left: -9999px; top: 0; width: 1px; height: 1px;
      overflow: hidden; opacity: 0; pointer-events: none; user-select: none;
    }

    /* 내부 상태 저장소(번역 금지) */
    #sourceText {
      position: absolute; left: -9999px; top: 0; width: 1px; height: 1px;
      overflow: hidden; opacity: 0.001;
    }
  </style>
</head>

<body>
  <!-- 출력은 번역 허용(translate 속성 없음) -->
  <div class="text-output" id="outputText" aria-live="off"></div>

  <!-- 언어 앵커 -->
  <div id="langAnchor" lang="ko" aria-hidden="true">
    한글 한국어 가나다라마바사아자차카타파하 바람, 공백, 말과 글 사이의 여백.
    이 페이지의 원문 언어는 한국어입니다.
  </div>

  <!-- 내부 상태(번역 금지) -->
  <div id="sourceText" translate="no" lang="zxx" aria-hidden="true"></div>

  <div id="statusHint" translate="no">ready</div>
  <footer>처언천히 또박또박 소리 내 읽어보세요</footer>

  <script>
    /***********************
     * 전역 상태
     ***********************/
    const MAX_STROKE = 2;
    const BLUR_MULTIPLIER = 20;
    const BIT_INTERVAL_MS = 1000;

    let isAllBlurred = false;
    let isReloading = false;
    let hexQueue = [];
    let displayChars = [];
    let bitInterval = null;
    let rhythmTimer = null;   // setTimeout 체인 관리
    let translateSafeMode = false; // ★ 번역-세이프 모드 스위치

    let currentSourceString = ""; // 원문은 오직 JS 변수로만

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = "ko-KR"; // 동적 변경 안함(깜빡임 유발 요인 제거)

    const output = document.getElementById("outputText");
    const source = document.getElementById("sourceText");
    const statusHint = document.getElementById("statusHint");

    const poems = [
      `“의미 없는 노성을 토하며 두억시니들은 끊임없이 두 손으로, 혹 손이 없을 경우에는 입으로 물을 머금어 강물을 ‘파내었다.’ 당연한 일이지만 같은 부피의 흙에 대해서라면 소용이 있었을 그 방법도 거세게 흐르는 급류에는 아무런 영향을 끼치지 못하고 있었다.두억시니들은 아무리 퍼내어도 줄어들지 않는 강물에 난처해하고 분노했다. 그러나 두억시니는 그 짓을 멈추지 않았다. 수백의 두억시니가 강변에 몰려서서 강물을 퍼내고 있었고 그보다 많은 두억시니들이 그들의 배후에서 의미를 빚지 못하는 단어들로 주위를 소란스럽게 만들고 있었다. 무익한 목적에 바쳐진 과도한 노고가 자아내는 것은 웃음이나 슬픔뿐이다.” \n이영도의 ‘눈물을 마시는 새’ 중 발췌`,
      `네 발바닥 즐거운! 푸르다! 손! 밤! 아홉의 오른쪽 물거품!  `,
      `심심한 장미를 콧구멍에-!  `,
      `딱딱하게 끊는 망치 바르면!  `,
      `무거운 해 늙어 태어나면 개나리 웃지요.  `,
      `크낙새 뿌리 무침? 파란 냄새 삼각형!  `,
      `팔짝 뛰는 토끼색 칠한 재채기 세 쌍만 던져!  `,
      `‘의미를 빚지 못한 단어로 이루어진’ 문장들은 소설 『눈물을 마시는 새』에 등장하는 두억시니의 대사이다. 공백으로 공백을 정의하기 적절한 텍스트로서 두억시니의 말을 인용했다. 소설 속 두억시니는 신을 잃은 종족이다. 이들은 이치에 어긋난 육체와 공백으로 얼룩진 정신을 가졌다. 두억시니 모두의 정신은 서로 연결되었으며 스스로를 ‘나’들이라고 지칭한다. 두억시니의 모순적 정체성은 공백과 닮았다. 이 글을 쓴 글쓴이와 화자이자 독자인 당신은 의미가 되지 못한 글을 통해 글자 사이의 공백이 된다. 두억시니 같은 ‘나’들이 된다.  \n메타공백의 글쓴이 생각`,
    ];

    const whitespaceHexMap = {
      '\u200B':'0','\u200C':'1','\u200D':'2','\u2060':'3',
      '\u00A0':'4','\u2002':'5','\u2003':'6','\u2004':'7',
      '\u2005':'8','\u2006':'9','\u2007':'a','\u2008':'b',
      '\u2009':'c','\u200A':'d','\u202F':'e','\u205F':'f'
    };
    const whitespaceChars = Object.keys(whitespaceHexMap);

    function setStatus(msg){ statusHint.textContent = msg; }

    function doReload(){
      if (translateSafeMode) return; // 번역 중엔 새로고침 금지(깜빡임 유발)
      if (isReloading) return;
      isReloading = true;
      location.reload();
    }

    function getRandomBitSpace() {
      const ch = whitespaceChars[(Math.random()*whitespaceChars.length)|0];
      const hx = whitespaceHexMap[ch];
      return { isSpace:true, hex:hx,
        html:`<span class="bit-space" translate="no" title="hex: ${hx}">${ch}</span>`
      };
    }

    function updateDisplay() {
      // 번역 중에는 DOM 업데이트 최소화(필요할 때만)
      const html = displayChars.map(o=>{
        if (o.isSpace) return o.html;
        if (o.char === '\n') return '<br>';
        const strokePx = Math.min(o.stroke, MAX_STROKE);
        const blurPx   = strokePx * BLUR_MULTIPLIER;
        return `<span class="char" style="-webkit-text-stroke-width:${strokePx}px; filter: blur(${blurPx}px)">${o.char}</span>`;
      }).join('');
      if (output.innerHTML !== html) output.innerHTML = html;

      if (!translateSafeMode) {
        const total   = displayChars.filter(o=>!o.isSpace).length;
        const blurred = displayChars.filter(o=>!o.isSpace && o.stroke >= MAX_STROKE).length;
        if (!isAllBlurred && total>0 && blurred===total){
          isAllBlurred = true;
          stopDynamics();
          recognition.stop();
          doReload();
        }
      }
    }

    function insertRandomBitSpace(){
      if (translateSafeMode) return; // 번역 중엔 정지
      const unblurredCount = displayChars.filter(o=>!o.isSpace && o.stroke<MAX_STROKE).length;
      if (isAllBlurred || unblurredCount===0){ clearInterval(bitInterval); bitInterval=null; return; }

      const spaceObj = getRandomBitSpace();
      if (displayChars.length && displayChars.at(-1).isSpace) displayChars.pop();

      const pos = (Math.random()*Math.max(1, displayChars.length-1))|0;
      displayChars.splice(pos, 0, spaceObj);

      hexQueue.push(spaceObj.hex);
      if (hexQueue.length===4){
        const rndChar = currentSourceString[(Math.random()*currentSourceString.length)|0] || ' ';
        displayChars.splice(pos,4,{char:rndChar, stroke:MAX_STROKE, isSpace:false});
        hexQueue = [];
      }
      updateDisplay();
    }

    function startRhythm(){
      let beat = 0; const timings=[2500,1900,1600];
      function nextBeat(){
        if (translateSafeMode) { rhythmTimer=null; return; } // 번역 중엔 루프 정지
        output.style.paddingLeft  = `${(Math.random()*30)|0}px`;
        output.style.paddingRight = `${(Math.random()*30)|0}px`;

        let i = displayChars.length-1;
        while(i>=0 && (displayChars[i].isSpace || displayChars[i].stroke>=MAX_STROKE)) i--;
        if (i>=0) displayChars[i].stroke++;

        updateDisplay();
        beat=(beat+1)%timings.length;
        rhythmTimer = setTimeout(nextBeat, timings[beat]);
      }
      nextBeat();
    }

    function rebuildFromSourceString(s){
      currentSourceString = s || "";
      hexQueue = [];
      isAllBlurred = false;

      // 내부 기록(번역 금지 DOM)
      source.textContent = currentSourceString;

      displayChars = currentSourceString.split('').map(ch=>({char:ch, stroke:0, isSpace:false}));
      updateDisplay();
    }

    /***********************
     * 음성인식(번역 중엔 중단)
     ***********************/
    recognition.onresult = (evt)=>{
      if (translateSafeMode) return; // 번역 중엔 중단
      const transcript = evt.results[evt.results.length-1][0].transcript.trim();
      if (!transcript) return;

      for (let i=0;i<displayChars.length;i++){
        const o = displayChars[i];
        if (!o.isSpace && transcript.includes(o.char)){
          const sp = getRandomBitSpace();
          displayChars[i]=sp;
          hexQueue.push(sp.hex);
          if (hexQueue.length===4){
            const rnd = currentSourceString[(Math.random()*currentSourceString.length)|0] || ' ';
            const start = Math.max(0, i-3);
            displayChars.splice(start,4,{char:rnd, stroke:0, isSpace:false});
            hexQueue=[];
          }
        }
      }
      updateDisplay();
    };
    recognition.onerror = e => console.error("Speech error:", e.error);
    recognition.onend   = () => { if (!translateSafeMode){ try{ recognition.start(); }catch{} } };

    /***********************
     * 번역-세이프 모드 제어
     * - 크롬/구글 번역이 활성화되면 html에 'translated-ltr/rtl' 클래스를 붙이거나
     *   번역 배너 iframe을 삽입합니다. 이 신호를 감지해 동작을 일시 정지합니다.
     ***********************/
    function isTranslateActive(){
      const html = document.documentElement;
      if (/\btranslated-(ltr|rtl)\b/.test(html.className)) return true;
      if (document.querySelector('iframe.goog-te-banner-frame')) return true;
      if (location.hostname.includes('translate.goog')) return true;
      return false;
    }

    function startDynamics(){
      // 이미 돌아가면 패스
      if (!bitInterval) bitInterval = setInterval(insertRandomBitSpace, BIT_INTERVAL_MS);
      if (!rhythmTimer) startRhythm();
      try{ recognition.start(); }catch{}
      setStatus('running');
    }

    function stopDynamics(){
      if (bitInterval){ clearInterval(bitInterval); bitInterval=null; }
      if (rhythmTimer){ clearTimeout(rhythmTimer); rhythmTimer=null; }
      try{ recognition.stop(); }catch{}
    }

    function enterTranslateSafeMode(){
      if (translateSafeMode) return;
      translateSafeMode = true;
      stopDynamics();
      setStatus('translation-safe mode'); // 아주 옅게 표시
    }

    function exitTranslateSafeMode(){
      if (!translateSafeMode) return;
      translateSafeMode = false;
      setStatus('resumed');
      startDynamics();
    }

    // HTML class/DOM 변화를 감지해서 모드 전환
    const translateObserver = new MutationObserver(()=>{
      if (isTranslateActive()) enterTranslateSafeMode();
      else                     exitTranslateSafeMode();
    });
    translateObserver.observe(document.documentElement, { attributes:true, attributeFilter:['class'] });

    // 배너 iframe 등장/제거도 감지
    const bodyObserver = new MutationObserver(()=>{
      if (isTranslateActive()) enterTranslateSafeMode();
      else                     exitTranslateSafeMode();
    });
    bodyObserver.observe(document.body, { childList:true, subtree:true });

    // 주기적 폴링(보험)
    setInterval(()=>{
      if (isTranslateActive()) enterTranslateSafeMode();
      else                     exitTranslateSafeMode();
    }, 1000);

    /***********************
     * 시작 루틴
     ***********************/
    function start(){
      // 한국어 lang 속성 유지(탐지기 되돌림 방지)
      if (document.documentElement.lang !== 'ko') document.documentElement.lang = 'ko';

      let shown = JSON.parse(localStorage.getItem('shownPoemIndexes')) || [];
      if (shown.length >= poems.length) shown = [];
      const avail = poems.map((_,i)=>i).filter(i=>!shown.includes(i));
      const idx = avail[Math.floor(Math.random()*avail.length)];
      shown.push(idx);
      localStorage.setItem('shownPoemIndexes', JSON.stringify(shown));

      rebuildFromSourceString(poems[idx]);

      // 번역이 이미 켜져 있으면 세이프 모드부터, 아니면 바로 시작
      if (isTranslateActive()) enterTranslateSafeMode();
      else startDynamics();
    }

    /***********************
     * 입력 → 새로고침(번역 중엔 차단)
     ***********************/
    document.body.addEventListener('click', ()=>{ doReload(); });
    document.addEventListener('keydown', (e)=>{ e.preventDefault(); doReload(); }, { passive:false });

    // 게임패드도 번역 중엔 차단
    let gamepadIndexes = [], prevButtonStates = {};
    window.addEventListener('gamepadconnected', (e)=>{
      if (!gamepadIndexes.includes(e.gamepad.index)) gamepadIndexes.push(e.gamepad.index);
    });
    window.addEventListener('gamepaddisconnected', (e)=>{
      gamepadIndexes = gamepadIndexes.filter(i=>i!==e.gamepad.index);
    });
    function pollGamepads(){
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      gamepadIndexes.forEach(idx=>{
        const gp = pads[idx]; if (!gp) return;
        gp.buttons.forEach((btn,bIndex)=>{
          const key = `${idx}_${bIndex}`;
          const was = prevButtonStates[key] || false;
          const now = btn.pressed===true;
          if (now && !was) doReload();
          prevButtonStates[key] = now;
        });
      });
      requestAnimationFrame(pollGamepads);
    }
    requestAnimationFrame(pollGamepads);

    window.onload = start;
  </script>
</body>
</html>
