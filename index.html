<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>메타공백; 두억시니의 낭독</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="공백으로 공백을 섞어짜기" />
  <meta name="keywords" content="메타공백, 두억시니, 공백문자, 쓰기, 말하기" />
  <meta name="author" content="김지영" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="메타공백; 두억시니의 낭독" />
  <meta property="og:description" content="공백으로 공백을 섞어짜기" />
  <meta property="og:locale" content="ko_KR" />
  <meta name="theme-color" content="#ffffff" />
  <style>
    @font-face{
      font-family:'MapoGoldenPier';
      src:url('https://gcore.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/MapoGoldenPierA.woff') format('woff');
      font-weight:normal;font-style:normal;letter-spacing:-5px;
    }
    html,body{height:100%;margin:0;padding:0;overflow:hidden;}
    body{
      font-family:'MapoGoldenPier','Noto Sans KR',sans-serif;
      background:#fff;display:flex;justify-content:center;position:relative;cursor:pointer;
    }
    .text-output{
      font-size:1.5rem;white-space:pre-wrap;padding:1.5rem;padding-top:20%;
      min-height:1200px;max-width:800px;width:100%;text-align:left;line-height:1.9;
      box-sizing:border-box;overflow-wrap:break-word;word-break:keep-all;transition:padding .3s ease;
    }
    .char{display:inline-block;-webkit-text-stroke-color:#000;color:#000;
      -webkit-text-stroke-linejoin:round;-webkit-text-stroke-linecap:round;}
    .bit-space{color:transparent;position:relative;cursor:help;}
    .bit-space::after{content:" ";position:absolute;color:rgba(0,0,0,0);}
    footer{
      position:fixed;bottom:0;left:0;width:100%;text-align:left;font-size:.8rem;font-weight:300;
      padding:1rem;font-family:'Noto Sans KR';pointer-events:none;
    }
    #sourceText{
      position:absolute;left:-9999px;top:0;width:1px;height:auto;opacity:.001;
      pointer-events:none;user-select:none;white-space:pre-wrap;
    }
    #statusHint{
      position:fixed;top:10px;right:10px;font-family:'Noto Sans KR';pointer-events:auto;
      font-size:.9rem;font-weight:600;color:#000;background:#fff;border:1px solid #000;border-radius:8px;
      padding:6px 10px;cursor:pointer;user-select:none;
    }
    #statusHint:active{transform:translateY(1px);}
  </style>
</head>
<body>
  <!-- 실제 출력(번역 금지) -->
  <div class="text-output" id="outputText" translate="no" aria-live="off"></div>
  <!-- 번역/원문 소스(번역 허용) -->
  <div id="sourceText" translate="yes"></div>

  <div id="statusHint" translate="no" role="button" aria-label="Toggle Language">LANG: ko-KR · click to EN</div>
  <footer>처언천히 또박또박 소리 내 읽어보세요</footer>

  <script>
    /******************************************************************
     * 번역 모드 설정
     *  - "inline": 프록시 없이 내부 문자열 토글(권장: 안정/오프라인/전시용)
     *  - "proxy" : translate.google.com 프록시 사용(네트워크/정책 이슈로 불안정)
     ******************************************************************/
    const TRANSLATE_MODE = "inline"; // "proxy" 로 바꾸면 프록시 시도

    /********************** (0) 상태/DOM 참조 **********************/
    const statusHint = document.getElementById("statusHint");
    const output = document.getElementById("outputText");
    const source = document.getElementById("sourceText");

    /********************** (1) 텍스트 데이터 **********************/
    // KO 원본
    const poemsKO = [
`“의미 없는 노성을 토하며 두억시니들은 끊임없이 두 손으로, 혹 손이 없을 경우에는 입으로 물을 머금어 강물을 ‘파내었다.’ 당연한 일이지만 같은 부피의 흙에 대해서라면 소용이 있었을 그 방법도 거세게 흐르는 급류에는 아무런 영향을 끼치지 못하고 있었다.두억시니들은 아무리 퍼내어도 줄어들지 않는 강물에 난처해하고 분노했다. 그러나 두억시니는 그 짓을 멈추지 않았다. 수백의 두억시니가 강변에 몰려서서 강물을 퍼내고 있었고 그보다 많은 두억시니들이 그들의 배후에서 의미를 빚지 못하는 단어들로 주위를 소란스럽게 만들고 있었다. 무익한 목적에 바쳐진 과도한 노고가 자아내는 것은 웃음이나 슬픔뿐이다.” 
이영도의 ‘눈물을 마시는 새’ 중 발췌`,
`네 발바닥 즐거운! 푸르다! 손! 밤! 아홉의 오른쪽 물거품!`,
`심심한 장미를 콧구멍에-!`,
`딱딱하게 끊는 망치 바르면!`,
`무거운 해 늙어 태어나면 개나리 웃지요.`,
`크낙새 뿌리 무침? 파란 냄새 삼각형!`,
`팔짝 뛰는 토끼색 칠한 재채기 세 쌍만 던져!`,
`‘의미를 빚지 못한 단어로 이루어진’ 문장들은 소설 『눈물을 마시는 새』에 등장하는 두억시니의 대사이다. 공백으로 공백을 정의하기 적절한 텍스트로서 두억시니의 말을 인용했다. 소설 속 두억시니는 신을 잃은 종족이다. 이들은 이치에 어긋난 육체와 공백으로 얼룩진 정신을 가졌다. 두억시니 모두의 정신은 서로 연결되었으며 스스로를 ‘나’들이라고 지칭한다. 두억시니의 모순적 정체성은 공백과 닮았다. 이 글을 쓴 글쓴이와 화자이자 독자인 당신은 의미가 되지 못한 글을 통해 글자 사이의 공백이 된다. 두억시니 같은 ‘나’들이 된다.  
메타공백의 글쓴이 생각`,
    ];

    // EN 번역(임시 번역본: 필요시 내가 문학적으로 다듬어 줄게)
    const poemsEN = [
`“Uttering meaningless wails, the dukshini ceaselessly scooped the river— with two hands, or, lacking hands, by holding water in their mouths. Of course, the method that might have worked on a like volume of soil had no effect on the raging torrent. They were embarrassed and enraged at a river that never diminished no matter how they bailed. Yet they did not stop. Hundreds crowded the bank, bailing, and even more behind them clattered the air with words that could not congeal into meaning. Excessive labor devoted to a useless end yields only laughter or sorrow.” 
—Excerpt from Lee Yeongdo’s *The Bird That Drinks Tears*`,
`Your four soles, delighted! Green! Hand! Night! Foam to the right of nine!`,
`A bored rose into the nostrils—!`,
`Apply a hammer that snaps, stiffly!`,
`When a heavy sun grows old and is born, the forsythia smiles.`,
`Crested ibis root salad? A blue smell, a triangle!`,
`Throw three pairs of leaping, rabbit-colored, painted sneezes!`,
`The sentences “made of words that fail to make meaning” are lines spoken by dukshini in the novel *The Bird That Drinks Tears*. I quoted them as a fitting text to define blankness by blanks. In the novel, the dukshini are a people who have lost their god—bodies against reason, minds blotched with blanks. Every dukshini’s mind is linked; they call themselves “we-I.” Their paradoxical identity resembles the blank. You—the writer of this text, its voice, and its reader—through writing that cannot become meaning, become the blank between letters. You become “we-I,” like dukshini.  
—Thoughts of the author of *Meta-Blank*`,
    ];

    // 현재 선택된 인덱스/언어
    let currentIndex = 0;
    let currentLang = "ko"; // "ko" | "en" (필요시 "ja" 확장 가능)

    /********************** (2) 프록시 모드 유틸(옵션) **********************/
    const DEFAULT_PUBLIC_URL = "https://met-awhite.netlify.app/";
    function isInsideGoogleTranslate(){
      const h=location.host, p=location.pathname||"";
      return (h.includes("translate.google.com") && p.startsWith("/translate")) || h.includes("translate.googleusercontent.com");
    }
    function makeTranslateUrl(originalUrl, tl="en"){
      return `https://translate.google.com/translate?sl=auto&tl=${tl}&u=${encodeURIComponent(originalUrl)}`;
    }
    function getQueryParam(name, urlStr = location.href){
      try{const u=new URL(urlStr);return u.searchParams.get(name);}catch{return null;}
    }
    function getOriginalUrlFromProxy(){
      const u=getQueryParam("u"); if(!u) return null;
      try{return decodeURIComponent(u);}catch{return u;}
    }

    /********************** (3) 공백→16진수 매핑/상수 **********************/
    const MAX_STROKE = 2;
    const BLUR_MULTIPLIER = 20;
    const BIT_INTERVAL_MS = 1000;

    const whitespaceHexMap = {
      '\u200B':'0','\u200C':'1','\u200D':'2','\u2060':'3',
      '\u00A0':'4','\u2002':'5','\u2003':'6','\u2004':'7',
      '\u2005':'8','\u2006':'9','\u2007':'a','\u2008':'b',
      '\u2009':'c','\u200A':'d','\u202F':'e','\u205F':'f'
    };
    const whitespaceChars = Object.keys(whitespaceHexMap);

    /********************** (4) 전역 상태 **********************/
    let isAllBlurred=false,isReloading=false,bitInterval,hexQueue=[];
    let displayChars=[]; // 실제 렌더링용
    let currentSourceString="";

    // 음성 인식(언어를 텍스트에 따라 자동 전환)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.continuous = true; recognition.interimResults = false; recognition.lang = "ko-KR";

    /********************** (5) 도움 함수 **********************/
    function doReload(){ if(isReloading) return; isReloading=true; location.reload(); }
    function setStatus(msg){ if(statusHint) statusHint.textContent = msg; }
    function guessLangFromText(s){
      const hasHira=/[\u3040-\u309F]/.test(s), hasKata=/[\u30A0-\u30FF]/.test(s), hasLatin=/[A-Za-z]/.test(s);
      if(hasHira||hasKata) return "ja-JP"; if(hasLatin) return "en-US"; return "ko-KR";
    }
    function getRandomBitSpace(){
      const ch = whitespaceChars[(Math.random()*whitespaceChars.length)|0];
      const hx = whitespaceHexMap[ch];
      return { isSpace:true, hex:hx, html:`<span class="bit-space" title="hex: ${hx}">${ch}</span>` };
    }

    function updateDisplay(){
      output.innerHTML = displayChars.map(o=>{
        if(o.isSpace) return o.html;
        if(o.char === '\n') return '<br>';
        const strokePx = Math.min(o.stroke, MAX_STROKE);
        const blurPx = strokePx * BLUR_MULTIPLIER;
        return `<span class="char" style="-webkit-text-stroke-width:${strokePx}px; filter: blur(${blurPx}px)">${o.char}</span>`;
      }).join('');

      const total = displayChars.filter(o=>!o.isSpace).length;
      const blurred = displayChars.filter(o=>!o.isSpace && o.stroke>=MAX_STROKE).length;
      if(!isAllBlurred && total>0 && blurred===total){
        isAllBlurred=true; clearInterval(bitInterval); recognition.stop(); doReload();
      }
    }

    function insertRandomBitSpace(){
      const unblurred = displayChars.filter(o=>!o.isSpace && o.stroke<MAX_STROKE).length;
      if(isAllBlurred || unblurred===0){ clearInterval(bitInterval); return; }

      const spaceObj=getRandomBitSpace();
      if(displayChars.length && displayChars.at(-1).isSpace) displayChars.pop();

      const pos=(Math.random()*Math.max(1, displayChars.length-1))|0;
      displayChars.splice(pos,0,spaceObj);
      hexQueue.push(spaceObj.hex);

      if(hexQueue.length===4){
        const rndChar = currentSourceString[(Math.random()*currentSourceString.length)|0] || ' ';
        displayChars.splice(pos,4,{char:rndChar, stroke:MAX_STROKE, isSpace:false});
        hexQueue=[];
      }
      updateDisplay();
    }

    function changeColorWithRhythm(){
      const timings=[2500,1900,1600]; let beat=0;
      function nextBeat(){
        output.style.paddingLeft = `${(Math.random()*30)|0}px`;
        output.style.paddingRight= `${(Math.random()*30)|0}px`;
        let i=displayChars.length-1;
        while(i>=0 && (displayChars[i].isSpace || displayChars[i].stroke>=MAX_STROKE)) i--;
        if(i>=0) displayChars[i].stroke++;
        updateDisplay();
        setTimeout(()=>{ beat=(beat+1)%timings.length; nextBeat(); }, timings[beat]);
      }
      nextBeat();
    }

    function rebuildFromSourceString(newString){
      currentSourceString = newString || "";
      hexQueue=[]; isAllBlurred=false;
      displayChars = currentSourceString.split('').map(ch=>({char:ch, stroke:0, isSpace:false}));

      const lang = guessLangFromText(currentSourceString);
      if(recognition.lang !== lang){
        try{ recognition.stop(); }catch{}
        recognition.lang = lang;
        try{ recognition.start(); }catch{}
      }
      updateDisplay();
    }

    /********************** (6) 음성 인식 콜백 **********************/
    recognition.onresult = (evt)=>{
      const t = evt.results[evt.results.length-1][0].transcript.trim();
      if(!t) return;
      for(let i=0;i<displayChars.length;i++){
        const o=displayChars[i];
        if(!o.isSpace && t.includes(o.char)){
          const sp=getRandomBitSpace(); displayChars[i]=sp; hexQueue.push(sp.hex);
          if(hexQueue.length===4){
            const rnd=currentSourceString[(Math.random()*currentSourceString.length)|0] || ' ';
            const start=Math.max(0,i-3);
            displayChars.splice(start,4,{char:rnd, stroke:0, isSpace:false});
            hexQueue=[];
          }
        }
      }
      updateDisplay();
    };
    recognition.onerror = e=>console.error("Speech error:", e.error);
    recognition.onend   = ()=>{ try{recognition.start();}catch{} };

    /********************** (7) 번역 감지(MO) **********************/
    function debounce(fn,delay=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args),delay); }; }
    const onSourceChanged = debounce(()=>{
      const translated = source.innerText || source.textContent || "";
      // 버튼 라벨은 currentLang으로 표시
      statusHint.textContent = (currentLang==="ko") ? "LANG: ko-KR · click to EN" : "LANG: en · click to KO";
      rebuildFromSourceString(translated);
    },300);
    const mo=new MutationObserver(onSourceChanged);
    mo.observe(source,{characterData:true, subtree:true, childList:true});

    /********************** (8) LANG 버튼 동작 **********************/
    statusHint.addEventListener("click",(e)=>{
      e.stopPropagation();
      if(TRANSLATE_MODE==="proxy"){
        // (선택) 프록시 모드: 403이 나면 포기하고 인라인로 전환 권장
        if(!isInsideGoogleTranslate()){
          location.href = makeTranslateUrl(DEFAULT_PUBLIC_URL, "en");
        }else{
          const orig = getOriginalUrlFromProxy();
          if(orig) location.href = orig; else alert("원본 주소를 찾지 못했어요.");
        }
        return;
      }

      // 인라인 모드: 배열 간 토글
      currentLang = (currentLang==="ko") ? "en" : "ko";
      const arr = (currentLang==="ko") ? poemsKO : poemsEN;
      // 현재 index의 같은 시를 반영
      source.textContent = arr[currentIndex];
      // 버튼 라벨 즉시 갱신
      statusHint.textContent = (currentLang==="ko") ? "LANG: ko-KR · click to EN" : "LANG: en · click to KO";
    });

    /********************** (9) 시작 시나리오 **********************/
    function start(){
      // 안겹치게 랜덤 선택(로컬스토리지)
      let shown = JSON.parse(localStorage.getItem('shownPoemIndexes')) || [];
      const total = poemsKO.length;
      if(shown.length>=total) shown=[];
      const avail=[...Array(total).keys()].filter(i=>!shown.includes(i));
      currentIndex = avail[Math.floor(Math.random()*avail.length)];
      shown.push(currentIndex);
      localStorage.setItem('shownPoemIndexes', JSON.stringify(shown));

      // 초기 언어는 ko
      currentLang = "ko";
      source.textContent = poemsKO[currentIndex];

      // 약간 늦춰 1차 렌더
      setTimeout(()=>{
        const initial = source.innerText || source.textContent || "";
        rebuildFromSourceString(initial);
        try{ recognition.start(); }catch{}
        changeColorWithRhythm();
        bitInterval = setInterval(insertRandomBitSpace, BIT_INTERVAL_MS);
      },150);
    }

    /********************** (10) 입력장치 리셋 **********************/
    document.body.addEventListener('click',(e)=>{ if(e.target===statusHint) return; doReload(); });
    document.addEventListener('keydown',(e)=>{ e.preventDefault(); doReload(); },{passive:false});

    let gamepadIndexes=[], prevButtonStates={};
    window.addEventListener('gamepadconnected',(e)=>{ if(!gamepadIndexes.includes(e.gamepad.index)) gamepadIndexes.push(e.gamepad.index); });
    window.addEventListener('gamepaddisconnected',(e)=>{ gamepadIndexes=gamepadIndexes.filter(i=>i!==e.gamepad.index); });
    function pollGamepads(){
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      gamepadIndexes.forEach(idx=>{
        const gp=pads[idx]; if(!gp) return;
        gp.buttons.forEach((btn,bIndex)=>{
          const key=`${idx}_${bIndex}`;
          const was=prevButtonStates[key]||false, is=btn.pressed===true;
          if(is && !was) doReload();
          prevButtonStates[key]=is;
        });
      });
      requestAnimationFrame(pollGamepads);
    }
    requestAnimationFrame(pollGamepads);

    /********************** (11) 시작! **********************/
    window.onload = start;
  </script>
</body>
</html>
