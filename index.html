<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë©”íƒ€ê³µë°±; ë‘ì–µì‹œë‹ˆì˜ ë‚­ë…</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ê³µë°±ìœ¼ë¡œ ê³µë°±ì„ ì„ì–´ì§œê¸°" />
  <meta name="keywords" content="ë©”íƒ€ê³µë°±, ë‘ì–µì‹œë‹ˆ, ê³µë°±ë¬¸ì, ì“°ê¸°, ë§í•˜ê¸°" />
  <meta name="author" content="ê¹€ì§€ì˜" />
  <!-- (ì„ íƒ) ë§Œì•½ í˜ì´ì§€ ì „ì²´ë¥¼ ì ˆëŒ€ ë²ˆì—­ë˜ì§€ ì•Šê²Œ í•˜ê³  ì‹¶ë‹¤ë©´ ë‹¤ìŒ ì¤„ì˜ ì£¼ì„ì„ í•´ì œ
  <meta name="google" content="notranslate" />
  -->
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ë©”íƒ€ê³µë°±; ë‘ì–µì‹œë‹ˆì˜ ë‚­ë…" />
  <meta property="og:description" content="ê³µë°±ìœ¼ë¡œ ê³µë°±ì„ ì„ì–´ì§œê¸°" />
  <meta property="og:locale" content="ko_KR" />
  <meta name="theme-color" content="#ffffff" />

  <style>
    @font-face {
      font-family: 'MapoGoldenPier';
      src: url('https://gcore.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/MapoGoldenPierA.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      letter-spacing: -5px;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      font-family: 'MapoGoldenPier', 'Noto Sans KR', sans-serif;
      background: #ffffff;
      display: flex;
      justify-content: center;
      position: relative;
      cursor: pointer;
    }

    .text-output {
      font-size: 1.5rem;
      white-space: pre-wrap;      /* ì¤„ë°”ê¿ˆ/ê³µë°± ìœ ì§€ */
      padding: 1.5rem;
      padding-top: 20%;
      min-height: 1200px;
      max-width: 800px;
      width: 100%;
      text-align: left;
      line-height: 1.9;
      box-sizing: border-box;
      overflow-wrap: break-word;  /* ê¸´ ë‹¨ì–´ ê°•ì œ ì¤„ë°”ê¿ˆ */
      word-break: keep-all;       /* í•œê¸€ ë‹¨ì–´ë‹¨ìœ„ ìœ ì§€ */
      transition: padding 0.3s ease;
    }

    .char {
      display: inline-block;
      -webkit-text-stroke-color: black;
      color: black;
      -webkit-text-stroke-linejoin: round;
      -webkit-text-stroke-linecap: round;
    }

    .bit-space {
      color: transparent;
      position: relative;
      cursor: help;
    }

    .bit-space::after {
      content: " ";
      position: absolute;
      color: rgba(0, 0, 0, 0);
    }

    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      text-align: left;
      font-size: 0.8rem;
      font-weight: 300;
      padding: 1rem;
      font-family: 'Noto Sans KR';
      pointer-events: none;
    }

    /* ìƒíƒœ í‘œì‹œ(ë””ë²„ê·¸) */
    #statusHint {
      position: fixed;
      top: 10px;
      right: 10px;
      font-family: 'Noto Sans KR';
      pointer-events: none;
      font-size: 0.8rem;
      font-weight: 300;
      color: rgba(0, 0, 0, 0);
    }

    /* ë‚´ë¶€ ìƒíƒœ ë³´ê´€ìš©: ì ˆëŒ€ ë²ˆì—­ ê¸ˆì§€ + í™”ë©´/ë³´ì¡°ê¸°ê¸° ëª¨ë‘ ìˆ¨ê¹€ */
    .notranslate {
      unicode-bidi: plaintext; /* ì¼ë¶€ ë²ˆì—­ê¸°/ë¦¬ë”ì˜ ê°„ì„­ì„ ì¤„ì´ëŠ” ë³´ì¡°ì±… */
    }
  </style>
</head>

<body>
  <!-- ì¶œë ¥ì€ ë²ˆì—­ í—ˆìš©(translate ì†ì„± ì œê±°). ì´ì œ êµ¬ê¸€ ë²ˆì—­ì´ ì¼œì§€ë©´ ì´ ì˜ì—­ë§Œ ë²ˆì—­ë©ë‹ˆë‹¤. -->
  <div class="text-output" id="outputText" aria-live="off"></div>

  <!-- ë‚´ë¶€ ìƒíƒœ ì €ì¥ìš©: DOMì— ë‘ë˜ ì ˆëŒ€ ë²ˆì—­/ì ‘ê·¼ë˜ì§€ ì•Šê²Œ ì²˜ë¦¬ -->
  <div id="sourceText"
       class="notranslate"
       translate="no"
       lang="zxx"
       aria-hidden="true"
       hidden></div>

  <div id="statusHint" translate="no" class="notranslate">ready</div>
  <footer>ì²˜ì–¸ì²œíˆ ë˜ë°•ë˜ë°• ì†Œë¦¬ ë‚´ ì½ì–´ë³´ì„¸ìš”</footer>

  <script>
    /***********************
     * ìƒìˆ˜/ì „ì—­ ìƒíƒœ
     ***********************/
    const MAX_STROKE = 2;
    const BLUR_MULTIPLIER = 20;
    const BIT_INTERVAL_MS = 1000;

    let isAllBlurred = false;
    let isReloading = false;
    let bitInterval;
    let hexQueue = [];
    let displayChars = [];

    // ì†ŒìŠ¤ ë¬¸ìì—´ì€ ì´ì œ "ì˜¤ì§ JS ë³€ìˆ˜"ë¡œë§Œ ê´€ë¦¬í•©ë‹ˆë‹¤.
    let currentSourceString = "";

    /***********************
     * ìŒì„± ì¸ì‹ ì¤€ë¹„
     ***********************/
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = "ko-KR"; // ì´ˆê¸°ê°’(í…ìŠ¤íŠ¸ì— ë§ì¶° ì•„ë˜ì—ì„œ ìë™ ì¡°ì •)

    /***********************
     * ì—˜ë¦¬ë¨¼íŠ¸ ì°¸ì¡°
     ***********************/
    const output = document.getElementById("outputText");
    const source = document.getElementById("sourceText");
    const statusHint = document.getElementById("statusHint");

    /***********************
     * ì›ë¬¸(ì‘í’ˆìš©) ë°ì´í„°
     * - ì´ ë°°ì—´ì€ ë²ˆì—­ë˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.
     * - ë”°ë¼ì„œ í™”ë©´ ë°”ê¹¥(ë‚´ë¶€ ìƒíƒœ)ë¡œë§Œ ì“°ê³ , ì¶œë ¥ì€ ë Œë”ë§ ê²°ê³¼ë§Œ ë²ˆì—­ë˜ê²Œ ë‘¡ë‹ˆë‹¤.
     ***********************/
    const poems = [
      `â€œì˜ë¯¸ ì—†ëŠ” ë…¸ì„±ì„ í† í•˜ë©° ë‘ì–µì‹œë‹ˆë“¤ì€ ëŠì„ì—†ì´ ë‘ ì†ìœ¼ë¡œ, í˜¹ ì†ì´ ì—†ì„ ê²½ìš°ì—ëŠ” ì…ìœ¼ë¡œ ë¬¼ì„ ë¨¸ê¸ˆì–´ ê°•ë¬¼ì„ â€˜íŒŒë‚´ì—ˆë‹¤.â€™ ë‹¹ì—°í•œ ì¼ì´ì§€ë§Œ ê°™ì€ ë¶€í”¼ì˜ í™ì— ëŒ€í•´ì„œë¼ë©´ ì†Œìš©ì´ ìˆì—ˆì„ ê·¸ ë°©ë²•ë„ ê±°ì„¸ê²Œ íë¥´ëŠ” ê¸‰ë¥˜ì—ëŠ” ì•„ë¬´ëŸ° ì˜í–¥ì„ ë¼ì¹˜ì§€ ëª»í•˜ê³  ìˆì—ˆë‹¤.ë‘ì–µì‹œë‹ˆë“¤ì€ ì•„ë¬´ë¦¬ í¼ë‚´ì–´ë„ ì¤„ì–´ë“¤ì§€ ì•ŠëŠ” ê°•ë¬¼ì— ë‚œì²˜í•´í•˜ê³  ë¶„ë…¸í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë‘ì–µì‹œë‹ˆëŠ” ê·¸ ì§“ì„ ë©ˆì¶”ì§€ ì•Šì•˜ë‹¤. ìˆ˜ë°±ì˜ ë‘ì–µì‹œë‹ˆê°€ ê°•ë³€ì— ëª°ë ¤ì„œì„œ ê°•ë¬¼ì„ í¼ë‚´ê³  ìˆì—ˆê³  ê·¸ë³´ë‹¤ ë§ì€ ë‘ì–µì‹œë‹ˆë“¤ì´ ê·¸ë“¤ì˜ ë°°í›„ì—ì„œ ì˜ë¯¸ë¥¼ ë¹šì§€ ëª»í•˜ëŠ” ë‹¨ì–´ë“¤ë¡œ ì£¼ìœ„ë¥¼ ì†Œë€ìŠ¤ëŸ½ê²Œ ë§Œë“¤ê³  ìˆì—ˆë‹¤. ë¬´ìµí•œ ëª©ì ì— ë°”ì³ì§„ ê³¼ë„í•œ ë…¸ê³ ê°€ ìì•„ë‚´ëŠ” ê²ƒì€ ì›ƒìŒì´ë‚˜ ìŠ¬í””ë¿ì´ë‹¤.â€ \nì´ì˜ë„ì˜ â€˜ëˆˆë¬¼ì„ ë§ˆì‹œëŠ” ìƒˆâ€™ ì¤‘ ë°œì·Œ`,
      `ë„¤ ë°œë°”ë‹¥ ì¦ê±°ìš´! í‘¸ë¥´ë‹¤! ì†! ë°¤! ì•„í™‰ì˜ ì˜¤ë¥¸ìª½ ë¬¼ê±°í’ˆ!  `,
      `ì‹¬ì‹¬í•œ ì¥ë¯¸ë¥¼ ì½§êµ¬ë©ì—-!  `,
      `ë”±ë”±í•˜ê²Œ ëŠëŠ” ë§ì¹˜ ë°”ë¥´ë©´!  `,
      `ë¬´ê±°ìš´ í•´ ëŠ™ì–´ íƒœì–´ë‚˜ë©´ ê°œë‚˜ë¦¬ ì›ƒì§€ìš”.  `,
      `í¬ë‚™ìƒˆ ë¿Œë¦¬ ë¬´ì¹¨? íŒŒë€ ëƒ„ìƒˆ ì‚¼ê°í˜•!  `,
      `íŒ”ì§ ë›°ëŠ” í† ë¼ìƒ‰ ì¹ í•œ ì¬ì±„ê¸° ì„¸ ìŒë§Œ ë˜ì ¸!  `,
      `â€˜ì˜ë¯¸ë¥¼ ë¹šì§€ ëª»í•œ ë‹¨ì–´ë¡œ ì´ë£¨ì–´ì§„â€™ ë¬¸ì¥ë“¤ì€ ì†Œì„¤ ã€ëˆˆë¬¼ì„ ë§ˆì‹œëŠ” ìƒˆã€ì— ë“±ì¥í•˜ëŠ” ë‘ì–µì‹œë‹ˆì˜ ëŒ€ì‚¬ì´ë‹¤. ê³µë°±ìœ¼ë¡œ ê³µë°±ì„ ì •ì˜í•˜ê¸° ì ì ˆí•œ í…ìŠ¤íŠ¸ë¡œì„œ ë‘ì–µì‹œë‹ˆì˜ ë§ì„ ì¸ìš©í–ˆë‹¤. ì†Œì„¤ ì† ë‘ì–µì‹œë‹ˆëŠ” ì‹ ì„ ìƒì€ ì¢…ì¡±ì´ë‹¤. ì´ë“¤ì€ ì´ì¹˜ì— ì–´ê¸‹ë‚œ ìœ¡ì²´ì™€ ê³µë°±ìœ¼ë¡œ ì–¼ë£©ì§„ ì •ì‹ ì„ ê°€ì¡Œë‹¤. ë‘ì–µì‹œë‹ˆ ëª¨ë‘ì˜ ì •ì‹ ì€ ì„œë¡œ ì—°ê²°ë˜ì—ˆìœ¼ë©° ìŠ¤ìŠ¤ë¡œë¥¼ â€˜ë‚˜â€™ë“¤ì´ë¼ê³  ì§€ì¹­í•œë‹¤. ë‘ì–µì‹œë‹ˆì˜ ëª¨ìˆœì  ì •ì²´ì„±ì€ ê³µë°±ê³¼ ë‹®ì•˜ë‹¤. ì´ ê¸€ì„ ì“´ ê¸€ì“´ì´ì™€ í™”ìì´ì ë…ìì¸ ë‹¹ì‹ ì€ ì˜ë¯¸ê°€ ë˜ì§€ ëª»í•œ ê¸€ì„ í†µí•´ ê¸€ì ì‚¬ì´ì˜ ê³µë°±ì´ ëœë‹¤. ë‘ì–µì‹œë‹ˆ ê°™ì€ â€˜ë‚˜â€™ë“¤ì´ ëœë‹¤.  \në©”íƒ€ê³µë°±ì˜ ê¸€ì“´ì´ ìƒê°`,
    ];

    /***********************
     * ìœ í‹¸/ìƒíƒœ í‘œì‹œ
     ***********************/
    function setStatus(msg) {
      if (statusHint) statusHint.textContent = msg;
    }

    function doReload() {
      if (isReloading) return;
      isReloading = true;
      location.reload();
    }

    /***********************
     * ë²ˆì—­ê¸° ê°„ì„­ì„ ë°›ì§€ ì•ŠëŠ” ë‚´ë¶€ ë¡œì§
     ***********************/
    const whitespaceHexMap = {
      '\u200B': '0', '\u200C': '1', '\u200D': '2', '\u2060': '3',
      '\u00A0': '4', '\u2002': '5', '\u2003': '6', '\u2004': '7',
      '\u2005': '8', '\u2006': '9', '\u2007': 'a', '\u2008': 'b',
      '\u2009': 'c', '\u200A': 'd', '\u202F': 'e', '\u205F': 'f'
    };
    const whitespaceChars = Object.keys(whitespaceHexMap);

    function getRandomBitSpace() {
      const ch = whitespaceChars[(Math.random() * whitespaceChars.length) | 0];
      const hx = whitespaceHexMap[ch];
      return {
        isSpace: true,
        hex: hx,
        html: `<span class="bit-space notranslate" translate="no" title="hex: ${hx}">${ch}</span>`
      };
    }

    function updateDisplay() {
      output.innerHTML = displayChars.map(o => {
        if (o.isSpace) return o.html;
        if (o.char === '\n') return '<br>';
        const strokePx = Math.min(o.stroke, MAX_STROKE);
        const blurPx = strokePx * BLUR_MULTIPLIER;
        return `<span class="char" style="-webkit-text-stroke-width:${strokePx}px; filter: blur(${blurPx}px)">${o.char}</span>`;
      }).join('');

      const total = displayChars.filter(o => !o.isSpace).length;
      const blurred = displayChars.filter(o => !o.isSpace && o.stroke >= MAX_STROKE).length;
      if (!isAllBlurred && total > 0 && blurred === total) {
        isAllBlurred = true;
        clearInterval(bitInterval);
        recognition.stop();
        doReload();
      }
    }

    function insertRandomBitSpace() {
      const unblurredCount = displayChars.filter(o => !o.isSpace && o.stroke < MAX_STROKE).length;
      if (isAllBlurred || unblurredCount === 0) {
        clearInterval(bitInterval);
        return;
      }

      const spaceObj = getRandomBitSpace();

      if (displayChars.length && displayChars.at(-1).isSpace) {
        displayChars.pop();
      }

      const pos = (Math.random() * Math.max(1, displayChars.length - 1)) | 0;
      displayChars.splice(pos, 0, spaceObj);

      hexQueue.push(spaceObj.hex);
      if (hexQueue.length === 4) {
        const rndChar = currentSourceString[(Math.random() * currentSourceString.length) | 0] || ' ';
        displayChars.splice(pos, 4, { char: rndChar, stroke: MAX_STROKE, isSpace: false });
        hexQueue = [];
      }

      updateDisplay();
    }

    function changeColorWithRhythm() {
      const timings = [2500, 1900, 1600];
      let beat = 0;

      function nextBeat() {
        output.style.paddingLeft = `${(Math.random() * 30) | 0}px`;
        output.style.paddingRight = `${(Math.random() * 30) | 0}px`;

        let i = displayChars.length - 1;
        while (i >= 0 && (displayChars[i].isSpace || displayChars[i].stroke >= MAX_STROKE)) i--;
        if (i >= 0) displayChars[i].stroke++;

        updateDisplay();

        setTimeout(() => {
          beat = (beat + 1) % timings.length;
          nextBeat();
        }, timings[beat]);
      }
      nextBeat();
    }

    function guessLangFromText(s) {
      const hasHira = /[\u3040-\u309F]/.test(s);
      const hasKata = /[\u30A0-\u30FF]/.test(s);
      const hasLatin = /[A-Za-z]/.test(s);
      if (hasHira || hasKata) return "ja-JP";
      if (hasLatin) return "en-US";
      return "ko-KR";
    }

    // ì˜¤ì§ JS ë³€ìˆ˜(currentSourceString)ë¡œë¶€í„° í™”ë©´ì„ ì¬êµ¬ì„±
    function rebuildFromSourceString(newString) {
      currentSourceString = newString || "";
      hexQueue = [];
      isAllBlurred = false;

      // ë‚´ë¶€ ì €ì¥ìš© divëŠ” ê¸°ë¡ë§Œ(ë””ë²„ê·¸Â·ê²€ì¦), ë²ˆì—­ ê¸ˆì§€/ìˆ¨ê¹€
      source.textContent = currentSourceString;

      displayChars = currentSourceString.split('').map(ch => ({
        char: ch, stroke: 0, isSpace: false
      }));

      // ìŒì„± ì¸ì‹ ì–¸ì–´ëŠ” ì›ë¬¸ ê¸°ì¤€(ë²ˆì—­ ê²°ê³¼ì™€ ë¬´ê´€)
      const lang = guessLangFromText(currentSourceString);
      if (recognition.lang !== lang) {
        try { recognition.stop(); } catch {}
        recognition.lang = lang;
        try { recognition.start(); } catch {}
      }

      updateDisplay();
    }

    /***********************
     * ìŒì„±ì¸ì‹ ì½œë°±
     ***********************/
    recognition.onresult = (evt) => {
      const transcript = evt.results[evt.results.length - 1][0].transcript.trim();
      if (!transcript) return;

      for (let i = 0; i < displayChars.length; i++) {
        const o = displayChars[i];
        if (!o.isSpace && transcript.includes(o.char)) {
          const sp = getRandomBitSpace();
          displayChars[i] = sp;
          hexQueue.push(sp.hex);

          if (hexQueue.length === 4) {
            const rnd = currentSourceString[(Math.random() * currentSourceString.length) | 0] || ' ';
            const start = Math.max(0, i - 3);
            displayChars.splice(start, 4, { char: rnd, stroke: 0, isSpace: false });
            hexQueue = [];
          }
        }
      }
      updateDisplay();
    };
    recognition.onerror = e => console.error("Speech error:", e.error);
    recognition.onend = () => {
      try { recognition.start(); } catch {}
    };

    /***********************
     * ì‹œì‘ ë£¨í‹´
     ***********************/
    function start() {
      // ì´ë¯¸ ë³´ì—¬ì¤€ ì¸ë±ìŠ¤ ê´€ë¦¬(ìˆœí™˜)
      let shown = JSON.parse(localStorage.getItem('shownPoemIndexes')) || [];
      if (shown.length >= poems.length) shown = [];
      const avail = poems.map((_, i) => i).filter(i => !shown.includes(i));
      const idx = avail[Math.floor(Math.random() * avail.length)];
      shown.push(idx);
      localStorage.setItem('shownPoemIndexes', JSON.stringify(shown));

      const selectedPoem = poems[idx];

      // ğŸ”´ í•µì‹¬: ì†ŒìŠ¤ ë¬¸ìì—´ì€ ì—¬ê¸°ì„œë§Œ ì„¤ì •. DOM ë²ˆì—­ê³¼ ë¬´ê´€.
      rebuildFromSourceString(selectedPoem);

      try { recognition.start(); } catch {}
      changeColorWithRhythm();
      bitInterval = setInterval(insertRandomBitSpace, BIT_INTERVAL_MS);
      setStatus(`LANG:${guessLangFromText(currentSourceString)}`);
    }

    /***********************
     * ì…ë ¥ ì¥ì¹˜(í´ë¦­/í‚¤ë³´ë“œ/ê²Œì„íŒ¨ë“œ) â†’ ìƒˆë¡œê³ ì¹¨
     ***********************/
    document.body.addEventListener('click', doReload);
    document.addEventListener('keydown', (e) => {
      e.preventDefault();
      doReload();
    }, { passive: false });

    let gamepadIndexes = [];
    let prevButtonStates = {};
    window.addEventListener('gamepadconnected', (e) => {
      if (!gamepadIndexes.includes(e.gamepad.index)) gamepadIndexes.push(e.gamepad.index);
      console.log('Gamepad connected:', e.gamepad.id);
    });
    window.addEventListener('gamepaddisconnected', (e) => {
      gamepadIndexes = gamepadIndexes.filter(i => i !== e.gamepad.index);
      console.log('Gamepad disconnected:', e.gamepad.id);
    });
    function pollGamepads() {
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      gamepadIndexes.forEach(idx => {
        const gp = pads[idx];
        if (!gp) return;
        gp.buttons.forEach((btn, bIndex) => {
          const key = `${idx}_${bIndex}`;
          const wasPressed = prevButtonStates[key] || false;
          const isPressed = btn.pressed === true;
          if (isPressed && !wasPressed) doReload();
          prevButtonStates[key] = isPressed;
        });
      });
      requestAnimationFrame(pollGamepads);
    }
    requestAnimationFrame(pollGamepads);

    window.onload = start;
  </script>
</body>
</html>
